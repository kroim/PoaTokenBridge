// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class UserRequestForAffirmation extends ethereum.Event {
  get params(): UserRequestForAffirmation__Params {
    return new UserRequestForAffirmation__Params(this);
  }
}

export class UserRequestForAffirmation__Params {
  _event: UserRequestForAffirmation;

  constructor(event: UserRequestForAffirmation) {
    this._event = event;
  }

  get messageId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get encodedData(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class UserRequestForSignature extends ethereum.Event {
  get params(): UserRequestForSignature__Params {
    return new UserRequestForSignature__Params(this);
  }
}

export class UserRequestForSignature__Params {
  _event: UserRequestForSignature;

  constructor(event: UserRequestForSignature) {
    this._event = event;
  }

  get messageId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get encodedData(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class RelayedMessage extends ethereum.Event {
  get params(): RelayedMessage__Params {
    return new RelayedMessage__Params(this);
  }
}

export class RelayedMessage__Params {
  _event: RelayedMessage;

  constructor(event: RelayedMessage) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get executor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get messageId(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get status(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }
}

export class AffirmationCompleted extends ethereum.Event {
  get params(): AffirmationCompleted__Params {
    return new AffirmationCompleted__Params(this);
  }
}

export class AffirmationCompleted__Params {
  _event: AffirmationCompleted;

  constructor(event: AffirmationCompleted) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get executor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get messageId(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get status(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }
}

export class SignedForUserRequest extends ethereum.Event {
  get params(): SignedForUserRequest__Params {
    return new SignedForUserRequest__Params(this);
  }
}

export class SignedForUserRequest__Params {
  _event: SignedForUserRequest;

  constructor(event: SignedForUserRequest) {
    this._event = event;
  }

  get signer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get messageHash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class CollectedSignatures extends ethereum.Event {
  get params(): CollectedSignatures__Params {
    return new CollectedSignatures__Params(this);
  }
}

export class CollectedSignatures__Params {
  _event: CollectedSignatures;

  constructor(event: CollectedSignatures) {
    this._event = event;
  }

  get authorityResponsibleForRelay(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get messageHash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get NumberOfCollectedSignatures(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class AMB extends ethereum.SmartContract {
  static bind(address: Address): AMB {
    return new AMB("AMB", address);
  }

  signature(_hash: Bytes, _index: BigInt): Bytes {
    let result = super.call("signature", "signature(bytes32,uint256):(bytes)", [
      ethereum.Value.fromFixedBytes(_hash),
      ethereum.Value.fromUnsignedBigInt(_index)
    ]);

    return result[0].toBytes();
  }

  try_signature(_hash: Bytes, _index: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "signature",
      "signature(bytes32,uint256):(bytes)",
      [
        ethereum.Value.fromFixedBytes(_hash),
        ethereum.Value.fromUnsignedBigInt(_index)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  message(_hash: Bytes): Bytes {
    let result = super.call("message", "message(bytes32):(bytes)", [
      ethereum.Value.fromFixedBytes(_hash)
    ]);

    return result[0].toBytes();
  }

  try_message(_hash: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall("message", "message(bytes32):(bytes)", [
      ethereum.Value.fromFixedBytes(_hash)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }
}
